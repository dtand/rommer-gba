<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Grid Annotator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .session-info { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .session-selector { margin-bottom: 20px; }
        .frame-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .frame-item { border: 1px solid #ccc; padding: 5px; text-align: center; }
        .frame-item.selected { border: 2px solid #007bff; background: #e6f0ff; }
        .frame-item.annotated { border: 4px solid #28a745 !important; }
        img { max-width: 120px; max-height: 90px; display: block; margin: 0 auto 5px; }
        .annotation { width: 100%; }
        select { padding: 8px; margin: 5px; }
        button { padding: 8px 16px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Frame Grid Annotator</h1>
    
    <div class="session-info" id="session-info">
        <div class="session-selector">
            <label>Select Session: 
                <select id="session-select" onchange="changeSession()">
                    <option value="">Loading sessions...</option>
                </select>
            </label>
            <button onclick="refreshSessions()">Refresh Sessions</button>
        </div>
        <div id="current-session-info" style="display:none;">
            <strong>Current Session:</strong> <span id="current-session-id"></span><br>
            <span id="session-metadata"></span>
        </div>
    </div>
    
    <form id="frame-form" onsubmit="return false;">
        <div class="frame-grid" id="frame-grid">
            <!-- Frames will be loaded here -->
        </div>
    </form>
    <!-- Modal for annotation input -->
    <div id="annotation-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4); z-index:1000;">
        <div style="background:#fff; max-width:400px; margin:10vh auto; padding:20px; border-radius:8px; box-shadow:0 2px 8px #0003;">
            <h2>Annotate Selected Frames</h2>
            <form id="annotation-form">
                <label>Context:<br><input type="text" id="context" name="context" style="width:100%"></label><br><br>
                <label>Scene:<br><input type="text" id="scene" name="scene" style="width:100%"></label><br><br>
                <label>Tags (comma separated):<br><input type="text" id="tags" name="tags" style="width:100%"></label><br><br>
                <label>Description:<br><textarea id="description" name="description" style="width:100%" rows="3"></textarea></label><br><br>
                <button type="submit">Save Annotation</button>
                <button type="button" onclick="closeModal()">Cancel</button>
            </form>
        </div>
    </div>
    <script>
let selectedFrames = new Set();
let lastSelectedFrame = null;
let frameOrder = [];
let allFrames = [];
let framesWithContext = [];
let framesLoaded = 0;
const FRAMES_PER_BATCH = 50;
let loadingFrames = false;
let currentSessionId = null;

// Get session ID from URL or template variable
function getCurrentSessionId() {
    const pathSegments = window.location.pathname.split('/').filter(s => s);
    if (pathSegments.length > 0) {
        return pathSegments[0];
    }
    // Fallback to template variable if available
    const sessionIdFromTemplate = '{{ session_id if session_id else "" }}';
    return sessionIdFromTemplate || null;
}

// Build API URLs with session support
function apiUrl(endpoint, ...params) {
    if (currentSessionId) {
        return `/api/${endpoint}/${currentSessionId}${params.length ? '/' + params.join('/') : ''}`;
    } else {
        return `/api/${endpoint}${params.length ? '/' + params.join('/') : ''}`;
    }
}

function refreshSessions() {
    fetch('/api/sessions')
        .then(res => res.json())
        .then(data => {
            const select = document.getElementById('session-select');
            select.innerHTML = '<option value="">Select a session...</option>';
            
            data.sessions.forEach(session => {
                const option = document.createElement('option');
                option.value = session.session_id;
                option.textContent = `${session.session_id} (${session.metadata.total_frames} frames)`;
                if (session.session_id === currentSessionId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // If we have a current session, show its info
            if (currentSessionId) {
                const currentSession = data.sessions.find(s => s.session_id === currentSessionId);
                if (currentSession) {
                    showSessionInfo(currentSession);
                }
            }
        })
        .catch(err => {
            console.error('Error loading sessions:', err);
            document.getElementById('session-select').innerHTML = '<option value="">Error loading sessions</option>';
        });
}

function showSessionInfo(session) {
    document.getElementById('current-session-id').textContent = session.session_id;
    const metadata = session.metadata;
    document.getElementById('session-metadata').innerHTML = `
        Created: ${new Date(metadata.created_at).toLocaleString()}<br>
        Total Frames: ${metadata.total_frames}<br>
        Frame Range: ${metadata.frame_range?.min}-${metadata.frame_range?.max}
    `;
    document.getElementById('current-session-info').style.display = 'block';
}

function changeSession() {
    const select = document.getElementById('session-select');
    const newSessionId = select.value;
    
    if (newSessionId !== currentSessionId) {
        if (newSessionId) {
            // Navigate to session-specific URL
            window.location.href = `/${newSessionId}`;
        } else {
            // Navigate to root
            window.location.href = '/';
        }
    }
}

function toggleFrame(frame, event) {
    const el = document.getElementById('frame-' + frame);
    if (event && event.shiftKey && lastSelectedFrame !== null && frameOrder.length > 0) {
        // Range selection
        const startIdx = frameOrder.indexOf(String(lastSelectedFrame));
        const endIdx = frameOrder.indexOf(String(frame));
        if (startIdx !== -1 && endIdx !== -1) {
            const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
            for (let i = from; i <= to; i++) {
                const f = frameOrder[i];
                selectedFrames.add(f);
                const div = document.getElementById('frame-' + f);
                if (div) div.classList.add('selected');
            }
        }
    } else {
        if (selectedFrames.has(frame)) {
            selectedFrames.delete(frame);
            el.classList.remove('selected');
        } else {
            selectedFrames.add(frame);
            el.classList.add('selected');
        }
        lastSelectedFrame = frame;
    }
}

function loadFrames() {
    fetch(apiUrl('frames'))
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                document.getElementById('frame-grid').innerHTML = `<p>Error: ${data.error}</p>`;
                return;
            }
            frameOrder = data.frames.map(f => String(f.frame));
            allFrames = data.frames;
            framesWithContext = [];
            framesLoaded = 0;
            const grid = document.getElementById('frame-grid');
            grid.innerHTML = '';
            loadNextFrames();
        })
        .catch(err => {
            console.error('Error loading frames:', err);
            document.getElementById('frame-grid').innerHTML = '<p>Error loading frames</p>';
        });
}

function loadNextFrames() {
    if (loadingFrames) return;
    loadingFrames = true;
    const nextBatch = allFrames.slice(framesLoaded, framesLoaded + FRAMES_PER_BATCH);
    const framePromises = nextBatch.map(frame =>
        fetch(apiUrl('frame_context', frame.frame))
            .then(res => ({ frame: frame.frame, hasContext: res.status === 200 }))
            .catch(() => ({ frame: frame.frame, hasContext: false }))
    );
    Promise.all(framePromises).then(batchWithContext => {
        framesWithContext = framesWithContext.concat(batchWithContext);
        const grid = document.getElementById('frame-grid');
        batchWithContext.forEach(({ frame, hasContext }) => {
            const div = document.createElement('div');
            div.className = 'frame-item' + (hasContext ? ' annotated' : '');
            div.id = 'frame-' + frame;
            div.onclick = (e) => toggleFrame(frame, e);
            div.innerHTML = `<img src="${apiUrl('frame_image', frame)}" alt="Frame ${frame}"><br>Frame ${frame}`;
            div.onmouseenter = (e) => showFrameDataPopup(frame, div);
            div.onmouseleave = hideFrameDataPopup;
            grid.appendChild(div);
        });
        framesLoaded += nextBatch.length;
        loadingFrames = false;
        
        // Load more frames when near the end
        if (framesLoaded < allFrames.length) {
            setTimeout(() => {
                const lastVisibleFrame = Array.from(document.querySelectorAll('.frame-item')).pop();
                if (lastVisibleFrame) {
                    const observer = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            loadNextFrames();
                            observer.disconnect();
                        }
                    });
                    observer.observe(lastVisibleFrame);
                }
            }, 100);
        }
    });
}

// Popup for frame event.json data
let popupDiv = null;
function showFrameDataPopup(frame, anchorEl) {
    fetch(apiUrl('frame_event', frame))
        .then(res => res.ok ? res.json() : null)
        .then(data => {
            if (!data) return;
            if (!popupDiv) {
                popupDiv = document.createElement('div');
                popupDiv.style.position = 'fixed';
                popupDiv.style.zIndex = 2000;
                popupDiv.style.background = '#fff';
                popupDiv.style.border = '1px solid #888';
                popupDiv.style.boxShadow = '0 2px 8px #0003';
                popupDiv.style.padding = '10px';
                popupDiv.style.maxWidth = '400px';
                popupDiv.style.fontSize = '12px';
                document.body.appendChild(popupDiv);
            }
            let html = `<b>Frame ${frame} event.json</b><br><pre style="white-space:pre-wrap;word-break:break-all;max-height:300px;overflow:auto;">`;
            html += JSON.stringify(data, null, 2);
            html += '</pre>';
            popupDiv.innerHTML = html;
            // Position popup near anchorEl
            const rect = anchorEl.getBoundingClientRect();
            popupDiv.style.left = (rect.right + 10) + 'px';
            popupDiv.style.top = (rect.top) + 'px';
            popupDiv.style.display = 'block';
        });
}
function hideFrameDataPopup() {
    if (popupDiv) popupDiv.style.display = 'none';
}

        window.addEventListener('scroll', function() {
            const scrollY = window.scrollY || window.pageYOffset;
            const viewport = window.innerHeight;
            const fullHeight = document.body.offsetHeight;
            if (scrollY + viewport > fullHeight - 300) {
                if (framesLoaded < allFrames.length) {
                    loadNextFrames();
                }
            }
        });
        function openModal() {
            document.getElementById('annotation-modal').style.display = 'block';
            document.getElementById('scene').focus();
        }
        function closeModal() {
            document.getElementById('annotation-modal').style.display = 'none';
            document.getElementById('annotation-form').reset();
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                if (selectedFrames.size > 0) {
                    openModal();
                    e.preventDefault();
                }
            }
        });
        document.getElementById('annotation-form').onsubmit = function(e) {
            e.preventDefault();
            const context = document.getElementById('context').value;
            const scene = document.getElementById('scene').value;
            const tags = document.getElementById('tags').value;
            const description = document.getElementById('description').value;
            const framesToUpdate = Array.from(selectedFrames);
            
            fetch(apiUrl('annotate'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ frames: framesToUpdate, annotation: { context, scene, tags, description } })
            }).then(res => res.json()).then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                // Only update the annotated frames' borders
                framesToUpdate.forEach(frame => {
                    const div = document.getElementById('frame-' + frame);
                    if (div) div.classList.add('annotated');
                });
                selectedFrames.clear();
                closeModal();
            }).catch(err => {
                console.error('Error saving annotation:', err);
                alert('Error saving annotation');
            });
        };

        // Initialize the page
        window.onload = function() {
            currentSessionId = getCurrentSessionId();
            refreshSessions();
            if (currentSessionId) {
                loadFrames();
            }
        };
    </script>
</body>
</html>
