<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Grid Annotator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .session-info { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .session-selector { margin-bottom: 20px; }
        .frame-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .frame-item { border: 1px solid #ccc; padding: 5px; text-align: center; }
        .frame-item.selected { border: 4px solid #007bff; background: #e6f0ff; }
        .frame-item.annotated { border: 4px solid #28a745 !important; }
        .frame-item.selected.annotated { border: 4px solid #007bff !important; background: #e6f0ff; }
        img { max-width: 120px; max-height: 90px; display: block; margin: 0 auto 5px; }
        .annotation { width: 100%; }
        select { padding: 8px; margin: 5px; }
        button { padding: 8px 16px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Frame Grid Annotator</h1>
    
    <div class="session-info" id="session-info">
        <div class="session-selector">
            <label>Select Session: 
                <select id="session-select" onchange="changeSession()">
                    <option value="">Loading sessions...</option>
                </select>
            </label>
            <button onclick="refreshSessions()">Refresh Sessions</button>
        </div>
        <div id="current-session-info" style="display:none;">
            <strong>Current Session:</strong> <span id="current-session-id"></span><br>
            <div id="completion-info" style="margin: 10px 0;">
                <strong>Completion:</strong> <span id="completion-percentage">0%</span> 
                (<span id="annotated-count">0</span> of <span id="total-frames">0</span> frames annotated)
                <div style="background: #e0e0e0; height: 10px; border-radius: 5px; margin: 5px 0; overflow: hidden;">
                    <div id="completion-bar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
            </div>
            <span id="session-metadata"></span>
        </div>
    </div>
    
    <form id="frame-form" onsubmit="return false;">
        <div class="frame-grid" id="frame-grid">
            <!-- Frames will be loaded here -->
        </div>
    </form>
    <!-- Modal for annotation input -->
    <div id="annotation-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4); z-index:1000;">
        <div style="background:#fff; max-width:400px; margin:10vh auto; padding:20px; border-radius:8px; box-shadow:0 2px 8px #0003;">
            <h2>Annotate Selected Frames</h2>
            <form id="annotation-form">
                <label>Context:<br><input type="text" id="context" name="context" style="width:100%"></label><br><br>
                <label>Scene:<br><input type="text" id="scene" name="scene" style="width:100%"></label><br><br>
                <label>Tags (comma separated):<br><input type="text" id="tags" name="tags" style="width:100%"></label><br><br>
                <label>Description:<br><textarea id="description" name="description" style="width:100%" rows="3"></textarea></label><br><br>
                <button type="submit">Save Annotation</button>
                <button type="button" onclick="closeModal()">Cancel</button>
            </form>
        </div>
    </div>
    <script>
let selectedFrames = new Set();
let lastSelectedFrame = null;
let frameOrder = [];
let allFrames = [];
let framesWithContext = [];
let framesLoaded = 0;
const FRAMES_PER_BATCH = 50;
let loadingFrames = false;
let currentSessionId = null;

// Input history for modal form fields
let inputHistory = {
    context: [],
    scene: [],
    tags: [],
    description: []
};
let currentHistoryIndex = {
    context: -1,
    scene: -1,
    tags: -1,
    description: -1
};

// Load input history from localStorage
function loadInputHistory() {
    const stored = localStorage.getItem('annotationInputHistory');
    if (stored) {
        inputHistory = JSON.parse(stored);
    }
}

// Save input history to localStorage
function saveInputHistory() {
    localStorage.setItem('annotationInputHistory', JSON.stringify(inputHistory));
}

// Add value to input history
function addToHistory(fieldName, value) {
    if (value && value.trim()) {
        // Remove existing occurrence if present
        const index = inputHistory[fieldName].indexOf(value);
        if (index > -1) {
            inputHistory[fieldName].splice(index, 1);
        }
        // Add to beginning of array
        inputHistory[fieldName].unshift(value);
        // Keep only last 20 entries
        if (inputHistory[fieldName].length > 20) {
            inputHistory[fieldName] = inputHistory[fieldName].slice(0, 20);
        }
        saveInputHistory();
    }
}

// Handle arrow key navigation in form fields
function setupFormFieldNavigation() {
    const fields = ['context', 'scene', 'tags', 'description'];
    
    fields.forEach(fieldName => {
        const field = document.getElementById(fieldName);
        field.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                
                const history = inputHistory[fieldName];
                if (history.length === 0) return;
                
                if (e.key === 'ArrowUp') {
                    currentHistoryIndex[fieldName] = Math.min(currentHistoryIndex[fieldName] + 1, history.length - 1);
                } else if (e.key === 'ArrowDown') {
                    currentHistoryIndex[fieldName] = Math.max(currentHistoryIndex[fieldName] - 1, -1);
                }
                
                if (currentHistoryIndex[fieldName] >= 0) {
                    field.value = history[currentHistoryIndex[fieldName]];
                } else {
                    field.value = '';
                }
            }
        });
        
        // Reset history index when user starts typing
        field.addEventListener('input', function(e) {
            currentHistoryIndex[fieldName] = -1;
        });
    });
}

// Initialize input history on page load
loadInputHistory();

// Completion tracking functions
function updateCompletionStats() {
    const totalFrames = allFrames.length;
    const annotatedFrames = document.querySelectorAll('.frame-item.annotated').length;
    const percentage = totalFrames > 0 ? Math.round((annotatedFrames / totalFrames) * 100) : 0;
    
    document.getElementById('completion-percentage').textContent = percentage + '%';
    document.getElementById('annotated-count').textContent = annotatedFrames;
    document.getElementById('total-frames').textContent = totalFrames;
    document.getElementById('completion-bar').style.width = percentage + '%';
}

function markFrameAsAnnotated(frameId) {
    const frameDiv = document.getElementById('frame-' + frameId);
    if (frameDiv) {
        frameDiv.classList.add('annotated');
        updateCompletionStats();
    }
}

// Get session ID from URL or template variable
function getCurrentSessionId() {
    const pathSegments = window.location.pathname.split('/').filter(s => s);
    if (pathSegments.length > 0) {
        return pathSegments[0];
    }
    // Fallback to template variable if available
    const sessionIdFromTemplate = '{{ session_id if session_id else "" }}';
    return sessionIdFromTemplate || null;
}

// Build API URLs with session support
function apiUrl(endpoint, ...params) {
    if (currentSessionId) {
        return `/api/${endpoint}/${currentSessionId}${params.length ? '/' + params.join('/') : ''}`;
    } else {
        return `/api/${endpoint}${params.length ? '/' + params.join('/') : ''}`;
    }
}

function refreshSessions() {
    fetch('/api/sessions')
        .then(res => res.json())
        .then(data => {
            const select = document.getElementById('session-select');
            select.innerHTML = '<option value="">Select a session...</option>';
            
            data.sessions.forEach(session => {
                const option = document.createElement('option');
                option.value = session.session_id;
                option.textContent = `${session.session_id} (${session.metadata.total_frames} frames)`;
                if (session.session_id === currentSessionId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // If we have a current session, show its info
            if (currentSessionId) {
                const currentSession = data.sessions.find(s => s.session_id === currentSessionId);
                if (currentSession) {
                    showSessionInfo(currentSession);
                }
            }
        })
        .catch(err => {
            console.error('Error loading sessions:', err);
            document.getElementById('session-select').innerHTML = '<option value="">Error loading sessions</option>';
        });
}

function showSessionInfo(session) {
    document.getElementById('current-session-id').textContent = session.session_id;
    const metadata = session.metadata;
    document.getElementById('session-metadata').innerHTML = `
        Created: ${new Date(metadata.created_at).toLocaleString()}<br>
        Total Frames: ${metadata.total_frames}<br>
        Frame Range: ${metadata.frame_range?.min}-${metadata.frame_range?.max}
    `;
    document.getElementById('current-session-info').style.display = 'block';
}

function changeSession() {
    const select = document.getElementById('session-select');
    const newSessionId = select.value;
    
    if (newSessionId !== currentSessionId) {
        if (newSessionId) {
            // Navigate to session-specific URL
            window.location.href = `/${newSessionId}`;
        } else {
            // Navigate to root
            window.location.href = '/';
        }
    }
}

function toggleFrame(frame, event) {
    const el = document.getElementById('frame-' + frame);
    if (event && event.shiftKey && lastSelectedFrame !== null && frameOrder.length > 0) {
        // Range selection
        const startIdx = frameOrder.indexOf(String(lastSelectedFrame));
        const endIdx = frameOrder.indexOf(String(frame));
        if (startIdx !== -1 && endIdx !== -1) {
            const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
            for (let i = from; i <= to; i++) {
                const f = frameOrder[i];
                selectedFrames.add(f);
                const div = document.getElementById('frame-' + f);
                if (div) div.classList.add('selected');
            }
        }
    } else {
        if (selectedFrames.has(frame)) {
            selectedFrames.delete(frame);
            el.classList.remove('selected');
        } else {
            selectedFrames.add(frame);
            el.classList.add('selected');
        }
        lastSelectedFrame = frame;
    }
}

function loadFrames() {
    fetch(apiUrl('frames'))
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                document.getElementById('frame-grid').innerHTML = `<p>Error: ${data.error}</p>`;
                return;
            }
            frameOrder = data.frames.map(f => String(f.frame));
            allFrames = data.frames;
            framesWithContext = [];
            framesLoaded = 0;
            const grid = document.getElementById('frame-grid');
            grid.innerHTML = '';
            loadNextFrames();
        })
        .catch(err => {
            console.error('Error loading frames:', err);
            document.getElementById('frame-grid').innerHTML = '<p>Error loading frames</p>';
        });
}

function loadNextFrames() {
    if (loadingFrames) return;
    loadingFrames = true;
    const nextBatch = allFrames.slice(framesLoaded, framesLoaded + FRAMES_PER_BATCH);
    const framePromises = nextBatch.map(frame =>
        fetch(apiUrl('frame_context', frame.frame))
            .then(res => ({ frame: frame.frame, hasContext: res.status === 200 }))
            .catch(() => ({ frame: frame.frame, hasContext: false }))
    );
    Promise.all(framePromises).then(batchWithContext => {
        framesWithContext = framesWithContext.concat(batchWithContext);
        const grid = document.getElementById('frame-grid');
        batchWithContext.forEach(({ frame, hasContext }) => {
            const div = document.createElement('div');
            div.className = 'frame-item' + (hasContext ? ' annotated' : '');
            div.id = 'frame-' + frame;
            div.onclick = (e) => toggleFrame(frame, e);
            div.innerHTML = `<img src="${apiUrl('frame_image', frame)}" alt="Frame ${frame}"><br>Frame ${frame}`;
            div.onmouseenter = (e) => showFrameDataPopup(frame, div);
            div.onmouseleave = hideFrameDataPopup;
            grid.appendChild(div);
        });
        
        // Update completion stats after loading frames
        updateCompletionStats();
        framesLoaded += nextBatch.length;
        loadingFrames = false;
        
        // Load more frames when near the end
        if (framesLoaded < allFrames.length) {
            setTimeout(() => {
                const lastVisibleFrame = Array.from(document.querySelectorAll('.frame-item')).pop();
                if (lastVisibleFrame) {
                    const observer = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            loadNextFrames();
                            observer.disconnect();
                        }
                    });
                    observer.observe(lastVisibleFrame);
                }
            }, 100);
        }
    });
}

// Popup for frame event.json data
let popupDiv = null;
function showFrameDataPopup(frame, anchorEl) {
    fetch(apiUrl('frame_event', frame))
        .then(res => res.ok ? res.json() : null)
        .then(data => {
            if (!data) return;
            if (!popupDiv) {
                popupDiv = document.createElement('div');
                popupDiv.style.position = 'fixed';
                popupDiv.style.zIndex = 2000;
                popupDiv.style.background = '#fff';
                popupDiv.style.border = '1px solid #888';
                popupDiv.style.boxShadow = '0 2px 8px #0003';
                popupDiv.style.padding = '10px';
                popupDiv.style.maxWidth = '500px';
                popupDiv.style.fontSize = '12px';
                document.body.appendChild(popupDiv);
            }
            let html = `<b>Frame ${frame} Data</b><br>`;
            
            // Display Frames
            if (data.frames_in_set) {
                html += `<b>Frames:</b> ${data.frames_in_set.join(', ')}<br>`;
            }
            
            // Display Program Counters
            if (data.pcs) {
                html += `<b>Program Counters:</b><br>`;
                data.pcs.forEach((pc, index) => {
                    html += `&nbsp;&nbsp;[${index}]: ${pc}<br>`;
                });
            }
            
            // Display Buttons
            if (data.buttons) {
                html += `<b>Buttons:</b><br>`;
                data.buttons.forEach((button, index) => {
                    const buttonText = Array.isArray(button) ? button.join('+') : (button === 'None' ? 'None' : button);
                    html += `&nbsp;&nbsp;[${index}]: ${buttonText}<br>`;
                });
            }
            
            // Show raw JSON in collapsible section for debugging
            html += `<br><details><summary>Raw JSON</summary><pre style="white-space:pre-wrap;word-break:break-all;max-height:200px;overflow:auto;">`;
            html += JSON.stringify(data, null, 2);
            html += '</pre></details>';
            
            popupDiv.innerHTML = html;
            // Position popup above anchorEl
            const rect = anchorEl.getBoundingClientRect();
            popupDiv.style.left = rect.left + 'px';
            popupDiv.style.top = (rect.top - popupDiv.offsetHeight - 10) + 'px';
            popupDiv.style.display = 'block';
        });
}
function hideFrameDataPopup() {
    if (popupDiv) popupDiv.style.display = 'none';
}

        window.addEventListener('scroll', function() {
            const scrollY = window.scrollY || window.pageYOffset;
            const viewport = window.innerHeight;
            const fullHeight = document.body.offsetHeight;
            if (scrollY + viewport > fullHeight - 300) {
                if (framesLoaded < allFrames.length) {
                    loadNextFrames();
                }
            }
        });
        function openModal() {
            document.getElementById('annotation-modal').style.display = 'block';
            document.getElementById('scene').focus();
            
            // Reset history indices
            Object.keys(currentHistoryIndex).forEach(key => {
                currentHistoryIndex[key] = -1;
            });
            
            // Set up form field navigation if not already done
            setupFormFieldNavigation();
        }
        function closeModal() {
            document.getElementById('annotation-modal').style.display = 'none';
            document.getElementById('annotation-form').reset();
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                if (selectedFrames.size > 0) {
                    openModal();
                    e.preventDefault();
                }
            }
        });
        document.getElementById('annotation-form').onsubmit = function(e) {
            e.preventDefault();
            const context = document.getElementById('context').value;
            const scene = document.getElementById('scene').value;
            const tags = document.getElementById('tags').value;
            const description = document.getElementById('description').value;
            const framesToUpdate = Array.from(selectedFrames);
            
            // Add values to input history
            addToHistory('context', context);
            addToHistory('scene', scene);
            addToHistory('tags', tags);
            addToHistory('description', description);
            
            fetch(apiUrl('annotate'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ frames: framesToUpdate, annotation: { context, scene, tags, description } })
            }).then(res => res.json()).then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                // Only update the annotated frames' borders
                framesToUpdate.forEach(frame => {
                    const div = document.getElementById('frame-' + frame);
                    if (div) div.classList.add('annotated');
                });
                selectedFrames.clear();
                closeModal();
                
                // Update completion stats after saving annotations
                updateCompletionStats();
            }).catch(err => {
                console.error('Error saving annotation:', err);
                alert('Error saving annotation');
            });
        };

        // Initialize the page
        window.onload = function() {
            currentSessionId = getCurrentSessionId();
            refreshSessions();
            if (currentSessionId) {
                loadFrames();
            }
        };
    </script>
</body>
</html>
