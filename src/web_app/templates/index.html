<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Frame Grid Annotator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; padding-top: 120px; }
        .session-info { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 5px; 
            margin-bottom: 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease;
        }
        .session-info.scrolled {
            background: #e9ecef;
            border-bottom: 2px solid #007bff;
        }
        .session-selector { margin-bottom: 20px; }
        .session-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: 10px;
        }
        .annotate-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .annotate-button:hover {
            background: #218838;
        }
        .annotate-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .frame-grid-container { margin: 0 40px; }
        .frame-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .frame-item { border: 1px solid #ccc; padding: 5px; text-align: center; }
        .frame-item.selected { border: 4px solid #007bff; background: #e6f0ff; }
        .frame-item.annotated { border: 4px solid #28a745 !important; }
        .frame-item.selected.annotated { border: 4px solid #007bff !important; background: #e6f0ff; }
        img { max-width: 120px; max-height: 90px; display: block; margin: 0 auto 5px; }
        .annotation { width: 100%; }
        select { padding: 8px; margin: 5px; }
        button { padding: 8px 16px; margin: 5px; }
        .recent-button { 
            padding: 3px 8px; 
            margin: 2px; 
            font-size: 11px; 
            background: #e9ecef; 
            border: 1px solid #ced4da; 
            border-radius: 3px; 
            cursor: pointer; 
            display: inline-block;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .recent-button:hover { 
            background: #007bff; 
            color: white; 
        }
    </style>
</head>
<body>
    <h1 style="margin-bottom: 20px;">Frame Grid Annotator</h1>
    
    <div class="session-info" id="session-info">
        <div class="session-selector">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <label>Select Session: 
                        <select id="session-select" onchange="changeSession()">
                            <option value="">Loading sessions...</option>
                        </select>
                    </label>
                    <div class="session-buttons">
                        <button onclick="refreshSessions()">Refresh Sessions</button>
                        <button class="annotate-button" id="bulk-annotate-btn" onclick="openBulkAnnotateModal()" disabled title="Select frames to enable bulk annotation">
                            üìù Annotate Selected
                        </button>
                        <button class="annotate-button" onclick="injectToDatabase()" title="Inject selected frames to database">
                            üíæ Inject to Database
                        </button>
                        <button class="annotate-button" onclick="toggleAnnotatedFrames()" title="Hide/show annotated frames">
                            üëÅÔ∏è Hide Annotated Frames
                        </button>
                    </div>
                </div>
                <div>
                    <a href="/memory/" style="padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px;">
                        üß† Memory Analysis
                    </a>
                </div>
            </div>
        </div>
        <div id="current-session-info" style="display:none;">
            <strong>Current Session:</strong> <span id="current-session-id"></span><br>
            <div id="completion-info" style="margin: 10px 0;">
                <strong>Completion:</strong> <span id="completion-percentage">0%</span> 
                (<span id="annotated-count">0</span> of <span id="total-frames">0</span> frames annotated)
                <div style="background: #e0e0e0; height: 10px; border-radius: 5px; margin: 5px 0; overflow: hidden;">
                    <div id="completion-bar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
            </div>
            <span id="session-metadata"></span>
        </div>
    </div>
    
    <form id="frame-form" onsubmit="return false;">
        <div class="frame-grid-container">
            <div class="frame-grid" id="frame-grid">
                <!-- Frames will be loaded here -->
            </div>
        </div>
    </form>
    <!-- Modal for annotation input -->
    <div id="annotation-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4); z-index:1000;">
        <div style="background:#fff; max-width:800px; margin:3vh auto; padding:30px; border-radius:8px; box-shadow:0 2px 8px #0003;">
            <h2 id="modal-title">Annotate Selected Frames</h2>
            
            <!-- Bulk annotation mode notice -->
            <div id="bulk-mode-notice" style="display: none; background: #e7f3ff; border: 1px solid #007bff; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                <strong>Bulk Annotation Mode:</strong> Only Context, Scene, and Tags will be applied to all selected frames. Description and Action fields will be ignored.
            </div>
            
            <!-- Two-column header with button events and frame snapshot -->
            <div id="modal-frame-snapshot" style="display: flex; gap: 20px; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border: 2px solid #dee2e6;">
                <!-- Left Column: Previous Button Events -->
                <div style="flex: 1;">
                    <div style="font-weight: bold; color: #495057; margin-bottom: 10px;">Previous Button Events</div>
                    <div id="button-events-display" style="font-family: monospace; font-size: 12px; background: #ffffff; padding: 10px; border: 1px solid #ced4da; border-radius: 3px; max-height: 150px; overflow-y: auto;">
                        Loading button events...
                    </div>
                </div>
                
                <!-- Right Column: Frame Image -->
                <div style="flex: 1; text-align: center;">
                    <div style="margin-bottom: 8px; font-weight: bold; color: #495057;" id="snapshot-frame-label">Frame Preview</div>
                    <img id="snapshot-image" src="" alt="Frame snapshot" style="max-width: 240px; max-height: 180px; border: 1px solid #ccc; border-radius: 3px;">
                </div>
            </div>
            
            <form id="annotation-form">
                <!-- Two-column layout -->
                <div style="display: flex; gap: 30px; margin-bottom: 25px;">
                    <!-- Left Column: Context, Scene -->
                    <div style="flex: 1; margin-right: 15px;">
                        <label>Context: <span id="context-confidence" style="font-size: 11px; color: #007bff; font-weight: normal;"></span><br>
                            <select id="context" name="context" style="width:100%; margin-bottom: 15px;" onchange="handleSelectChange('context')">
                                <option value="">Select context...</option>
                                <!-- Options will be populated dynamically -->
                                <option value="add_new">Add New +</option>
                            </select>
                        </label>
                        <div id="context_custom" style="display:none; margin-top:8px; margin-bottom: 15px;">
                            <input type="text" id="context_input" placeholder="Enter new context..." style="width:100%; margin-bottom: 8px;">
                            <button type="button" onclick="addCustomOption('context')" style="margin-right: 8px;">Add</button>
                            <button type="button" onclick="cancelCustomOption('context')">Cancel</button>
                        </div>
                        
                        <label>Scene: <span id="scene-confidence" style="font-size: 11px; color: #007bff; font-weight: normal;"></span><br><input type="text" id="scene" name="scene" style="width:100%; margin-bottom: 8px;" autocomplete="off"></label>
                        <div id="scene-recent" style="margin-bottom: 20px;">
                            <small style="color:#666;">Recent scenes:</small><br>
                            <div id="scene-buttons" style="margin-top:5px;"></div>
                        </div>
                        
                        <label>Tags:<br><input type="text" id="tags" name="tags" style="width:100%; margin-bottom: 8px;" autocomplete="off" placeholder="Enter comma-separated tags..."></label>
                        <div id="tags-recent" style="margin-bottom: 15px;">
                            <small style="color:#666;">Recommended tags:</small><br>
                            <div id="tags-buttons" style="margin-top:5px;"></div>
                        </div>
                    </div>
                    
                    <!-- Right Column: Action Classification -->
                    <div style="flex: 1; margin-left: 15px;">
                        <h3 style="margin: 0 0 20px 0; font-size: 14px;">Action Classification (Optional)</h3
                        >
                        <label>Action Type:<br>
                            <select id="action_type" name="action_type" style="width:100%; margin-bottom: 15px;" onchange="handleSelectChange('action_type')">
                                <option value="">Select action type...</option>
                                <!-- Options will be populated dynamically -->
                                <option value="add_new">Add New +</option>
                            </select>
                        </label>
                        <div id="action_type_custom" style="display:none; margin-top:8px; margin-bottom: 15px;">
                            <input type="text" id="action_type_input" placeholder="Enter new action type..." style="width:100%; margin-bottom: 8px;">
                            <button type="button" onclick="addCustomOption('action_type')" style="margin-right: 8px;">Add</button>
                            <button type="button" onclick="cancelCustomOption('action_type')">Cancel</button>
                        </div>
                        
                        <label>Player Intent:<br>
                            <select id="intent" name="intent" style="width:100%; margin-bottom: 15px;" onchange="handleSelectChange('intent')">
                                <option value="">Select intent...</option>
                                <!-- Options will be populated dynamically -->
                                <option value="add_new">Add New +</option>
                            </select>
                        </label>
                        <div id="intent_custom" style="display:none; margin-top:8px; margin-bottom: 15px;">
                            <input type="text" id="intent_input" placeholder="Enter new intent..." style="width:100%; margin-bottom: 8px;">
                            <button type="button" onclick="addCustomOption('intent')" style="margin-right: 8px;">Add</button>
                            <button type="button" onclick="cancelCustomOption('intent')">Cancel</button>
                        </div>
                        
                        <label>Outcome:<br>
                            <select id="outcome" name="outcome" style="width:100%; margin-bottom: 15px;">
                                <option value="">Select outcome...</option>
                                <!-- Options will be populated dynamically -->
                            </select>
                        </label>
                    </div>
                </div>
                
                <!-- Full-width Description row -->
                <div style="margin: 25px 0;">
                    <label>Description:<br><textarea id="description" name="description" style="width:100%; margin-top: 8px;" rows="3" autocomplete="off"></textarea></label>
                </div>
                
                <div style="margin-top: 25px;">
                    <button type="submit" style="margin-right: 10px;">Save Annotation</button>
                    <button type="button" onclick="closeModal()" style="margin-right: 10px;">Cancel</button>
                    <button type="button" onclick="clearCopiedAnnotation()" style="background:#dc3545;color:white;margin-left:10px;" title="Clear copied annotation data">Clear Copied</button>
                    <button type="button" onclick="resetAnnotations()" style="background:#fd7e14;color:white;margin-left:10px;" title="Reset annotations for selected frames">Reset Annotations</button>
                </div>
            </form>
        </div>
    </div>
    <script>
let selectedFrames = new Set();
let lastSelectedFrame = null;
let frameOrder = [];
let allFrames = [];
let framesWithContext = [];
let framesLoaded = 0;
const FRAMES_PER_BATCH = 20; // Reduced batch size for better performance
let loadingFrames = false;
let currentSessionId = null;
let isBulkMode = false;

// Handle sticky navigation and frame loading with throttling
let scrollTimeout;
function handleScrollEvents() {
    // Clear existing timeout
    if (scrollTimeout) {
        clearTimeout(scrollTimeout);
    }
    
    // Throttle scroll events to improve performance
    scrollTimeout = setTimeout(() => {
        // Handle sticky navigation
        handleStickyNav();
        
        // Handle infinite scroll for frame loading
        const scrollY = window.scrollY || window.pageYOffset;
        const viewport = window.innerHeight;
        const fullHeight = document.body.offsetHeight;
        
        // Load more frames when near the bottom (reduced threshold for better UX)
        if (scrollY + viewport > fullHeight - 200) {
            if (framesLoaded < allFrames.length && !loadingFrames) {
                loadNextFrames();
            }
        }
    }, 16); // ~60fps throttling
}

// Handle sticky navigation (called from throttled scroll handler)
function handleStickyNav() {
    const sessionInfo = document.getElementById('session-info');
    const scrolled = window.scrollY > 20;
    
    if (scrolled) {
        sessionInfo.classList.add('scrolled');
    } else {
        sessionInfo.classList.remove('scrolled');
    }
}

// Update bulk annotate button state
function updateBulkAnnotateButton() {
    const button = document.getElementById('bulk-annotate-btn');
    const hasSelection = selectedFrames.size > 0;
    
    button.disabled = !hasSelection;
    button.title = hasSelection 
        ? `Bulk annotate ${selectedFrames.size} selected frame(s)`
        : 'Select frames to enable bulk annotation';
}

// Input history for modal form fields
let inputHistory = {
    context: [],
    scene: [],
    tags: [],
    description: [],
    action_type: [],
    intent: [],
    outcome: []
};
let currentHistoryIndex = {
    context: -1,
    scene: -1,
    tags: -1,
    description: -1,
    action_type: -1,
    intent: -1,
    outcome: -1
};

// Copied annotation data
let copiedAnnotation = null;

// Annotation configuration
let annotationConfig = null;

// Load annotation configuration
async function loadAnnotationConfig() {
    try {
        const response = await fetch('/static/annotation_config.json');
        annotationConfig = await response.json();
        populateDropdowns();
    } catch (error) {
        console.error('Error loading annotation config:', error);
        // Fallback to empty config
        annotationConfig = {
            context_options: [],
            action_type_options: [],
            intent_options: [],
            outcome_options: []
        };
    }
}

// Populate dropdown options from config
function populateDropdowns() {
    if (!annotationConfig) return;
    
    // Populate context dropdown
    const contextSelect = document.getElementById('context');
    const contextAddNew = contextSelect.querySelector('option[value="add_new"]');
    annotationConfig.context_options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.textContent = option.label;
        contextSelect.insertBefore(optionElement, contextAddNew);
    });
    
    // Populate action_type dropdown
    const actionTypeSelect = document.getElementById('action_type');
    const actionTypeAddNew = actionTypeSelect.querySelector('option[value="add_new"]');
    annotationConfig.action_type_options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.textContent = option.label;
        actionTypeSelect.insertBefore(optionElement, actionTypeAddNew);
    });
    
    // Populate intent dropdown
    const intentSelect = document.getElementById('intent');
    const intentAddNew = intentSelect.querySelector('option[value="add_new"]');
    annotationConfig.intent_options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.textContent = option.label;
        intentSelect.insertBefore(optionElement, intentAddNew);
    });
    
    // Populate outcome dropdown (no add new option)
    const outcomeSelect = document.getElementById('outcome');
    annotationConfig.outcome_options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.textContent = option.label;
        outcomeSelect.appendChild(optionElement);
    });
}

// Load input history from localStorage
function loadInputHistory() {
    const stored = localStorage.getItem('annotationInputHistory');
    if (stored) {
        inputHistory = JSON.parse(stored);
    }
}

// Save input history to localStorage
function saveInputHistory() {
    localStorage.setItem('annotationInputHistory', JSON.stringify(inputHistory));
}

// Add value to input history
function addToHistory(fieldName, value) {
    if (!value || !value.trim()) return;
    
    // Initialize the field array if it doesn't exist
    if (!inputHistory[fieldName]) {
        inputHistory[fieldName] = [];
    }
    
    // Special handling for tags - split by comma and add each tag individually
    if (fieldName === 'tags') {
        const individualTags = value.split(',').map(tag => tag.trim()).filter(tag => tag);
        
        individualTags.forEach(tag => {
            // Remove if already exists (to move to front)
            const index = inputHistory[fieldName].indexOf(tag);
            if (index > -1) {
                inputHistory[fieldName].splice(index, 1);
            }
            
            // Add to front
            inputHistory[fieldName].unshift(tag);
        });
    } else {
        // Normal handling for other fields
        // Remove if already exists (to move to front)
        const index = inputHistory[fieldName].indexOf(value);
        if (index > -1) {
            inputHistory[fieldName].splice(index, 1);
        }
        
        // Add to front
        inputHistory[fieldName].unshift(value);
    }
    
    // Keep only last 20 entries
    if (inputHistory[fieldName].length > 20) {
        inputHistory[fieldName] = inputHistory[fieldName].slice(0, 20);
    }
    
    // Save to localStorage
    localStorage.setItem('annotationInputHistory', JSON.stringify(inputHistory));
}

// Update recent buttons for a field
function updateRecentButtons(fieldName) {
    const buttonsContainer = document.getElementById(fieldName + '-buttons');
    if (!buttonsContainer) return;
    
    buttonsContainer.innerHTML = '';
    const recentItems = inputHistory[fieldName] || [];
    
    if (fieldName === 'tags') {
        // For tags, show unique individual tags as recommendations
        const uniqueTags = [...new Set(recentItems)];
        uniqueTags.slice(0, 20).forEach(tag => {
            const button = document.createElement('button');
            button.textContent = tag;
            button.className = 'recent-button';
            button.type = 'button';
            button.title = `Add tag: ${tag}`;
            button.onclick = () => {
                const field = document.getElementById(fieldName);
                const currentTags = field.value.split(',').map(t => t.trim()).filter(t => t);
                
                // Only add if tag is not already present
                if (!currentTags.includes(tag)) {
                    if (field.value.trim()) {
                        field.value = field.value.trim() + ', ' + tag;
                    } else {
                        field.value = tag;
                    }
                }
                field.focus();
            };
            buttonsContainer.appendChild(button);
        });
    } else {
        // For other fields, show recent values
        recentItems.slice(0, 20).forEach(item => {
            const button = document.createElement('button');
            button.textContent = item;
            button.className = 'recent-button';
            button.type = 'button';
            button.title = item; // Full text on hover
            button.onclick = () => {
                const field = document.getElementById(fieldName);
                // For other fields, replace the content
                field.value = item;
                field.focus();
            };
            buttonsContainer.appendChild(button);
        });
    }
}

// Handle arrow key navigation in form fields
function setupFormFieldNavigation() {
    const fields = ['scene', 'tags', 'description']; // Added tags back to navigation
    
    fields.forEach(fieldName => {
        const field = document.getElementById(fieldName);
        if (!field) return; // Skip if field doesn't exist
        
        // For select fields, we'll handle them differently
        if (field.tagName === 'SELECT') {
            // For dropdowns, we can still use arrow keys but won't interfere with native behavior
            return;
        }
        
        field.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                
                const history = inputHistory[fieldName];
                if (history.length === 0) return;
                
                if (e.key === 'ArrowUp') {
                    currentHistoryIndex[fieldName] = Math.min(currentHistoryIndex[fieldName] + 1, history.length - 1);
                } else if (e.key === 'ArrowDown') {
                    currentHistoryIndex[fieldName] = Math.max(currentHistoryIndex[fieldName] - 1, -1);
                }
                
                if (currentHistoryIndex[fieldName] >= 0) {
                    field.value = history[currentHistoryIndex[fieldName]];
                } else {
                    field.value = '';
                }
            }
        });
        
        // Reset history index when user starts typing
        field.addEventListener('input', function(e) {
            currentHistoryIndex[fieldName] = -1;
        });
    });
}

// Initialize input history on page load
loadInputHistory();

// Initialize recent buttons on page load
function initializeRecentButtons() {
    updateRecentButtons('scene');
    updateRecentButtons('tags');
}

// Handle select change for custom options
function handleSelectChange(fieldName) {
    const select = document.getElementById(fieldName);
    const customDiv = document.getElementById(fieldName + '_custom');
    
    if (select.value === 'add_new') {
        customDiv.style.display = 'block';
        document.getElementById(fieldName + '_input').focus();
    } else {
        customDiv.style.display = 'none';
    }
}

// Add custom option to select
function addCustomOption(fieldName) {
    const input = document.getElementById(fieldName + '_input');
    const select = document.getElementById(fieldName);
    const customDiv = document.getElementById(fieldName + '_custom');
    const newValue = input.value.trim();
    
    if (newValue) {
        // Check if option already exists
        const existingOption = Array.from(select.options).find(option => 
            option.value.toLowerCase() === newValue.toLowerCase()
        );
        
        if (!existingOption) {
            // Add new option before "Add New +"
            const newOption = document.createElement('option');
            newOption.value = newValue.toLowerCase().replace(/\s+/g, '_');
            newOption.textContent = newValue;
            
            // Insert before "Add New +" option
            const addNewOption = select.querySelector('option[value="add_new"]');
            select.insertBefore(newOption, addNewOption);
        }
        
        // Select the new/existing option
        const targetValue = existingOption ? existingOption.value : newValue.toLowerCase().replace(/\s+/g, '_');
        select.value = targetValue;
        
        // Hide custom input
        customDiv.style.display = 'none';
        input.value = '';
        
        // Add to input history
        addToHistory(fieldName, newValue);
    }
}

// Cancel custom option input
function cancelCustomOption(fieldName) {
    const select = document.getElementById(fieldName);
    const customDiv = document.getElementById(fieldName + '_custom');
    const input = document.getElementById(fieldName + '_input');
    
    select.value = '';
    customDiv.style.display = 'none';
    input.value = '';
}

// Completion tracking functions
function updateCompletionStats() {
    const totalFrames = allFrames.length;
    const annotatedFrames = document.querySelectorAll('.frame-item.annotated').length;
    const percentage = totalFrames > 0 ? Math.round((annotatedFrames / totalFrames) * 100) : 0;
    
    document.getElementById('completion-percentage').textContent = percentage + '%';
    document.getElementById('annotated-count').textContent = annotatedFrames;
    document.getElementById('total-frames').textContent = totalFrames;
    document.getElementById('completion-bar').style.width = percentage + '%';
}

function markFrameAsAnnotated(frameId) {
    const frameDiv = document.getElementById('frame-' + frameId);
    if (frameDiv) {
        frameDiv.classList.add('annotated');
        updateCompletionStats();
    }
}

// Get session ID from URL or template variable
function getCurrentSessionId() {
    const pathSegments = window.location.pathname.split('/').filter(s => s);
    if (pathSegments.length > 0) {
        return pathSegments[0];
    }
    // Fallback to template variable if available
    const sessionIdFromTemplate = '{{ session_id if session_id else "" }}';
    return sessionIdFromTemplate || null;
}

// Build API URLs with session support
function apiUrl(endpoint, ...params) {
    if (currentSessionId) {
        return `/api/${endpoint}/${currentSessionId}${params.length ? '/' + params.join('/') : ''}`;
    } else {
        return `/api/${endpoint}${params.length ? '/' + params.join('/') : ''}`;
    }
}

function refreshSessions() {
    fetch('/api/sessions')
        .then(res => res.json())
        .then(data => {
            const select = document.getElementById('session-select');
            select.innerHTML = '<option value="">Select a session...</option>';
            
            data.sessions.forEach(session => {
                const option = document.createElement('option');
                option.value = session.session_id;
                option.textContent = `${session.session_id} (${session.metadata.total_frames} frames)`;
                if (session.session_id === currentSessionId) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            
            // If we have a current session, show its info
            if (currentSessionId) {
                const currentSession = data.sessions.find(s => s.session_id === currentSessionId);
                if (currentSession) {
                    showSessionInfo(currentSession);
                }
            }
        })
        .catch(err => {
            console.error('Error loading sessions:', err);
            document.getElementById('session-select').innerHTML = '<option value="">Error loading sessions</option>';
        });
}

function showSessionInfo(session) {
    document.getElementById('current-session-id').textContent = session.session_id;
    const metadata = session.metadata;
    document.getElementById('session-metadata').innerHTML = ``;
    document.getElementById('current-session-info').style.display = 'block';
}

function changeSession() {
    const select = document.getElementById('session-select');
    const newSessionId = select.value;
    
    if (newSessionId !== currentSessionId) {
        if (newSessionId) {
            // Navigate to session-specific URL
            window.location.href = `/${newSessionId}`;
        } else {
            // Navigate to root
            window.location.href = '/';
        }
    }
}

function toggleFrame(frame, event) {
    const el = document.getElementById('frame-' + frame);
    
    // Handle Ctrl+Click on annotated frames to copy annotation
    if (event && event.ctrlKey && el.classList.contains('annotated')) {
        copyAnnotation(frame);
        return; // Don't toggle selection when copying
    }
    
    if (event && event.shiftKey && lastSelectedFrame !== null && frameOrder.length > 0) {
        // Range selection
        const startIdx = frameOrder.indexOf(String(lastSelectedFrame));
        const endIdx = frameOrder.indexOf(String(frame));
        if (startIdx !== -1 && endIdx !== -1) {
            const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
            for (let i = from; i <= to; i++) {
                const f = frameOrder[i];
                selectedFrames.add(f);
                const div = document.getElementById('frame-' + f);
                if (div) div.classList.add('selected');
            }
        }
    } else {
        if (selectedFrames.has(frame)) {
            selectedFrames.delete(frame);
            el.classList.remove('selected');
        } else {
            selectedFrames.add(frame);
            el.classList.add('selected');
        }
        lastSelectedFrame = frame;
    }
    
    // Update bulk annotate button state
    updateBulkAnnotateButton();
}

function loadFrames() {
    fetch(apiUrl('frames'))
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                document.getElementById('frame-grid').innerHTML = `<p>Error: ${data.error}</p>`;
                return;
            }
            frameOrder = data.frames.map(f => String(f.frame));
            allFrames = data.frames;
            framesWithContext = [];
            framesLoaded = 0;
            const grid = document.getElementById('frame-grid');
            grid.innerHTML = '';
            loadNextFrames();
        })
        .catch(err => {
            console.error('Error loading frames:', err);
            document.getElementById('frame-grid').innerHTML = '<p>Error loading frames</p>';
        });
}

function loadNextFrames() {
    if (loadingFrames) return;
    loadingFrames = true;
    const nextBatch = allFrames.slice(framesLoaded, framesLoaded + FRAMES_PER_BATCH);
    
    // Load context info for the batch (faster, smaller responses)
    const framePromises = nextBatch.map(frame =>
        fetch(apiUrl('frame_context', frame.frame))
            .then(res => ({ frame: frame.frame, hasContext: res.status === 200 }))
            .catch(() => ({ frame: frame.frame, hasContext: false }))
    );
    
    Promise.all(framePromises).then(batchWithContext => {
        framesWithContext = framesWithContext.concat(batchWithContext);
        const grid = document.getElementById('frame-grid');
        
        // Create frame elements without images first (faster DOM update)
        const fragment = document.createDocumentFragment();
        
        batchWithContext.forEach(({ frame, hasContext }) => {
            const div = document.createElement('div');
            div.className = 'frame-item' + (hasContext ? ' annotated' : '');
            div.id = 'frame-' + frame;
            div.onclick = (e) => toggleFrame(frame, e);
            
            // Create placeholder initially, load image lazily
            div.innerHTML = `<div style="width: 120px; height: 90px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; margin: 0 auto 5px; border: 1px solid #ddd;">Loading...</div><br>Frame ${frame}`;
            
            div.onmouseenter = (e) => showFrameDataPopup(frame, div);
            div.onmouseleave = hideFrameDataPopup;
            
            fragment.appendChild(div);
        });
        
        // Add all elements to DOM at once
        grid.appendChild(fragment);
        
        // Now lazily load images using Intersection Observer
        batchWithContext.forEach(({ frame }) => {
            const div = document.getElementById('frame-' + frame);
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Load the actual image when it comes into view
                        div.innerHTML = `<img src="${apiUrl('frame_image', frame)}" alt="Frame ${frame}" loading="lazy"><br>Frame ${frame}`;
                        observer.unobserve(div);
                    }
                });
            }, { 
                rootMargin: '100px' // Start loading when within 100px of viewport
            });
            observer.observe(div);
        });
        
        // Update completion stats after loading frames
        updateCompletionStats();
        framesLoaded += nextBatch.length;
        loadingFrames = false;
    });
}

// Popup for frame event.json data
let popupDiv = null;
let previewDiv = null;

function showFrameDataPopup(frame, anchorEl) {
    // Create and show the larger frame preview
    if (!previewDiv) {
        previewDiv = document.createElement('div');
        previewDiv.style.position = 'fixed';
        previewDiv.style.zIndex = 1999; // Below popup but above everything else
        previewDiv.style.background = '#fff';
        previewDiv.style.border = '2px solid #007bff';
        previewDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
        previewDiv.style.padding = '10px';
        previewDiv.style.borderRadius = '8px';
        document.body.appendChild(previewDiv);
    }
    
    // Show larger version of the frame
    const rect = anchorEl.getBoundingClientRect();
    previewDiv.innerHTML = `<img src="${apiUrl('frame_image', frame)}" style="max-width: 300px; max-height: 225px; display: block;">
                           <div style="text-align: center; margin-top: 5px; font-weight: bold;">Frame ${frame}</div>`;
    previewDiv.style.left = (rect.left + rect.width/2 - 150) + 'px'; // Center above frame
    previewDiv.style.top = (rect.top - 250) + 'px'; // Position above frame
    previewDiv.style.display = 'block';
    
    // Show data popup
    fetch(apiUrl('frame_event', frame))
        .then(res => res.ok ? res.json() : null)
        .then(data => {
            if (!data) return;
            if (!popupDiv) {
                popupDiv = document.createElement('div');
                popupDiv.style.position = 'fixed';
                popupDiv.style.zIndex = 2000;
                popupDiv.style.background = '#fff';
                popupDiv.style.border = '1px solid #888';
                popupDiv.style.boxShadow = '0 2px 8px #0003';
                popupDiv.style.padding = '10px';
                popupDiv.style.maxWidth = '256px';
                popupDiv.style.minWidth = '128px';
                popupDiv.style.fontSize = '12px';
                document.body.appendChild(popupDiv);
            }
            let html = `<b>Frame ${frame} Data</b><br>`;
            
            // Display Frames
            if (data.frames_in_set) {
                html += `<b>Frames:</b> ${data.frames_in_set.join(', ')}<br>`;
            }
            
            // Display Buttons
            if (data.buttons) {
                html += `<b>Buttons:</b><br>`;
                data.buttons.forEach((button, index) => {
                    const buttonText = Array.isArray(button) ? button.join('+') : (button === 'None' ? 'None' : button);
                    html += `&nbsp;&nbsp;[${index}]: ${buttonText}<br>`;
                });
            }else {
                html += `<b>Buttons:</b> None<br>`;
            }
            
            // Show annotation description if present, otherwise show raw JSON
            if (data.annotations && data.annotations.description) {
                html += `<br><b>Annotations:</b>
                <br><b>Context:</b> ${data.annotations.context}
                <br><b>Scene:</b> ${data.annotations.scene}
                <br><b>Tags:</b> ${data.annotations.tags}
                <br><b>Description:</b> ${data.annotations.description}`;
                
                // Show action data if present
                if (data.annotations.action_type || data.annotations.intent || data.annotations.outcome) {
                    html += `<br><br><b>Action:</b>`;
                    if (data.annotations.action_type) html += `<br><b>Type:</b> ${data.annotations.action_type}`;
                    if (data.annotations.intent) html += `<br><b>Intent:</b> ${data.annotations.intent}`;
                    if (data.annotations.outcome) html += `<br><b>Outcome:</b> ${data.annotations.outcome}`;
                }
                
                html += `<br><br><small style="color:#666;">Ctrl+Click to copy annotation</small>`;
            } else {
                // Show raw JSON in collapsible section for debugging
                html += `<br><details><summary>Raw JSON</summary><pre style="white-space:pre-wrap;word-break:break-all;max-height:200px;overflow:auto;">`;
                html += JSON.stringify(data, null, 2);
                html += '</pre></details>';
            }
            
            popupDiv.innerHTML = html;
            // Position popup to the right of anchorEl
            const rect = anchorEl.getBoundingClientRect();
            popupDiv.style.left = (rect.right + 10) + 'px';
            popupDiv.style.top = rect.top + 'px';
            popupDiv.style.display = 'block';
        });
}

function hideFrameDataPopup() {
    if (popupDiv) popupDiv.style.display = 'none';
    if (previewDiv) previewDiv.style.display = 'none';
}

// Copy annotation from a frame
function copyAnnotation(frame) {
    fetch(apiUrl('frame_event', frame))
        .then(res => res.ok ? res.json() : null)
        .then(data => {
            if (data && data.annotations) {
                copiedAnnotation = {
                    context: data.annotations.context || '',
                    scene: data.annotations.scene || '',
                    tags: data.annotations.tags || '',
                    description: data.annotations.description || '',
                    action_type: data.annotations.action_type || '',
                    intent: data.annotations.intent || '',
                    outcome: data.annotations.outcome || ''
                };
                
                // Visual feedback - flash the frame briefly
                const frameEl = document.getElementById('frame-' + frame);
                if (frameEl) {
                    const original = frameEl.style.background;
                    frameEl.style.background = '#28a745';
                    frameEl.style.color = 'white';
                    setTimeout(() => {
                        frameEl.style.background = original;
                        frameEl.style.color = '';
                    }, 300);
                }
                
                // Update modal title to show copied data is available
                updateModalTitle();
            }
        })
        .catch(err => console.error('Error copying annotation:', err));
}

// Open bulk annotation modal
function openBulkAnnotateModal() {
    if (selectedFrames.size === 0) {
        alert('Please select frames to annotate.');
        return;
    }
    
    isBulkMode = true;
    openModal();
}

// Update modal title to show when copied data is available or bulk mode
function updateModalTitle() {
    const title = document.getElementById('modal-title');
    const bulkNotice = document.getElementById('bulk-mode-notice');
    
    if (isBulkMode) {
        title.textContent = `Bulk Annotate ${selectedFrames.size} Frames`;
        title.style.color = '#fd7e14';
        bulkNotice.style.display = 'block';
    } else if (copiedAnnotation) {
        title.textContent = 'Annotate Selected Frames (üìã Copied data available)';
        title.style.color = '#28a745';
        bulkNotice.style.display = 'none';
    } else {
        title.textContent = 'Annotate Selected Frames';
        title.style.color = '';
        bulkNotice.style.display = 'none';
    }
}

        // Use our optimized scroll handler
        window.addEventListener('scroll', handleScrollEvents, { passive: true });
        function openModal() {
            document.getElementById('annotation-modal').style.display = 'block';
            
            // Get the first selected frame to check for existing annotations
            const firstSelectedFrame = Array.from(selectedFrames)[0];
            // Get the last selected frame for the snapshot display
            const lastSelectedFrame = Array.from(selectedFrames).pop();
            
            // Update the frame snapshot
            updateModalFrameSnapshot();
            
            // In bulk mode, only populate with defaults, don't load existing annotations
            if (isBulkMode) {
                // Clear all fields first
                document.getElementById('context').value = '';
                document.getElementById('scene').value = '';
                document.getElementById('tags').value = '';
                document.getElementById('description').value = '';
                document.getElementById('action_type').value = '';
                document.getElementById('intent').value = '';
                document.getElementById('outcome').value = '';
                
                // Use recent values as defaults for bulk operations
                const lastContext = inputHistory.context && inputHistory.context.length > 0 ? inputHistory.context[0] : '';
                const lastScene = inputHistory.scene && inputHistory.scene.length > 0 ? inputHistory.scene[0] : '';
                const lastTags = inputHistory.tags && inputHistory.tags.length > 0 ? inputHistory.tags.slice(0, 3).join(', ') : '';
                
                document.getElementById('context').value = lastContext;
                document.getElementById('scene').value = lastScene;
                document.getElementById('tags').value = lastTags;
                
                // Disable action fields in bulk mode
                document.getElementById('action_type').disabled = true;
                document.getElementById('intent').disabled = true;
                document.getElementById('outcome').disabled = true;
                document.getElementById('description').disabled = true;
            } else {
                // Enable all fields in normal mode
                document.getElementById('action_type').disabled = false;
                document.getElementById('intent').disabled = false;
                document.getElementById('outcome').disabled = false;
                document.getElementById('description').disabled = false;
                
                // Normal single/multi-frame annotation logic (existing code)
                if (firstSelectedFrame) {
                    // Check if the frame has existing annotations
                    fetch(apiUrl('frame_event', firstSelectedFrame))
                        .then(res => res.ok ? res.json() : null)
                        .then(data => {
                            if (data && data.annotations && (data.annotations.context || data.annotations.scene || data.annotations.tags || data.annotations.description)) {
                                // Frame has existing annotations - use them
                                document.getElementById('context').value = data.annotations.context || '';
                                document.getElementById('scene').value = data.annotations.scene || '';
                                document.getElementById('tags').value = data.annotations.tags || '';
                                document.getElementById('description').value = data.annotations.description || '';
                                document.getElementById('action_type').value = data.annotations.action_type || '';
                                document.getElementById('intent').value = data.annotations.intent || '';
                                document.getElementById('outcome').value = data.annotations.outcome || '';
                                // Clear CNN confidence indicators
                                document.getElementById('context-confidence').textContent = '';
                                document.getElementById('scene-confidence').textContent = '';
                            } else if (copiedAnnotation) {
                                // Frame has no annotations but we have copied data - use copied data
                                document.getElementById('context').value = copiedAnnotation.context;
                                document.getElementById('scene').value = copiedAnnotation.scene;
                                document.getElementById('tags').value = copiedAnnotation.tags;
                                document.getElementById('description').value = copiedAnnotation.description;
                                document.getElementById('action_type').value = copiedAnnotation.action_type;
                                document.getElementById('intent').value = copiedAnnotation.intent;
                                document.getElementById('outcome').value = copiedAnnotation.outcome;
                                // Clear CNN confidence indicators
                                document.getElementById('context-confidence').textContent = '';
                                document.getElementById('scene-confidence').textContent = '';
                            } else {
                                // Frame has no annotations and no copied data - check CNN predictions first
                                let usedCnnPredictions = false;
                                
                                // Clear confidence indicators first
                                document.getElementById('context-confidence').textContent = '';
                                document.getElementById('scene-confidence').textContent = '';
                                
                                if (data && data.cnn_predictions) {
                                    const cnnContext = data.cnn_predictions.context;
                                    const cnnScene = data.cnn_predictions.scene;
                                    
                                    // Check if we have high-confidence predictions for both context and scene
                                    const hasHighConfidenceContext = cnnContext && cnnContext.confidence > 0.5;
                                    const hasHighConfidenceScene = cnnScene && cnnScene.confidence > 0.5;
                                    
                                    if (hasHighConfidenceContext || hasHighConfidenceScene) {
                                        // Use CNN predictions when available with high confidence
                                        if (hasHighConfidenceContext) {
                                            document.getElementById('context').value = cnnContext.prediction;
                                            document.getElementById('context-confidence').textContent = `(CNN: ${(cnnContext.confidence * 100).toFixed(1)}%)`;
                                        }
                                        if (hasHighConfidenceScene) {
                                            document.getElementById('scene').value = cnnScene.prediction;
                                            document.getElementById('scene-confidence').textContent = `(CNN: ${(cnnScene.confidence * 100).toFixed(1)}%)`;
                                        }
                                        
                                        // Clear description and tags when using CNN predictions
                                        document.getElementById('description').value = '';
                                        document.getElementById('tags').value = '';
                                        usedCnnPredictions = true;
                                    }
                                }
                                
                                // Only use last annotations if we didn't use CNN predictions
                                if (!usedCnnPredictions) {
                                    const lastContext = inputHistory.context && inputHistory.context.length > 0 ? inputHistory.context[0] : '';
                                    const lastScene = inputHistory.scene && inputHistory.scene.length > 0 ? inputHistory.scene[0] : '';
                                    const lastTags = inputHistory.tags && inputHistory.tags.length > 0 ? inputHistory.tags.slice(0, 3).join(', ') : '';
                                    const lastDescription = inputHistory.description && inputHistory.description.length > 0 ? inputHistory.description[0] : '';
                                    
                                    document.getElementById('context').value = lastContext;
                                    document.getElementById('scene').value = lastScene;
                                    document.getElementById('tags').value = lastTags;
                                    document.getElementById('description').value = lastDescription;
                                }
                                
                                // Leave action fields empty
                                document.getElementById('action_type').value = '';
                                document.getElementById('intent').value = '';
                                document.getElementById('outcome').value = '';
                            }
                        })
                        .catch(err => {
                            console.error('Error checking frame annotations:', err);
                            // Fallback to copied annotation or last annotations if API call fails
                            if (copiedAnnotation) {
                                document.getElementById('context').value = copiedAnnotation.context;
                                document.getElementById('scene').value = copiedAnnotation.scene;
                                document.getElementById('tags').value = copiedAnnotation.tags;
                                document.getElementById('description').value = copiedAnnotation.description;
                                document.getElementById('action_type').value = copiedAnnotation.action_type;
                                document.getElementById('intent').value = copiedAnnotation.intent;
                                document.getElementById('outcome').value = copiedAnnotation.outcome;
                            } else {
                                // Use last annotations (excluding actions)
                                const lastContext = inputHistory.context && inputHistory.context.length > 0 ? inputHistory.context[0] : '';
                                const lastScene = inputHistory.scene && inputHistory.scene.length > 0 ? inputHistory.scene[0] : '';
                                const lastTags = inputHistory.tags && inputHistory.tags.length > 0 ? inputHistory.tags.slice(0, 3).join(', ') : '';
                                const lastDescription = inputHistory.description && inputHistory.description.length > 0 ? inputHistory.description[0] : '';
                                
                                document.getElementById('context').value = lastContext;
                                document.getElementById('scene').value = lastScene;
                                document.getElementById('tags').value = lastTags;
                                document.getElementById('description').value = lastDescription;
                                // Leave action fields empty
                                document.getElementById('action_type').value = '';
                                document.getElementById('intent').value = '';
                                document.getElementById('outcome').value = '';
                            }
                        });
                } else {
                    // No frames selected - use copied annotation or last annotations
                    if (copiedAnnotation) {
                        document.getElementById('context').value = copiedAnnotation.context;
                        document.getElementById('scene').value = copiedAnnotation.scene;
                        document.getElementById('tags').value = copiedAnnotation.tags;
                        document.getElementById('description').value = copiedAnnotation.description;
                        document.getElementById('action_type').value = copiedAnnotation.action_type;
                        document.getElementById('intent').value = copiedAnnotation.intent;
                        document.getElementById('outcome').value = copiedAnnotation.outcome;
                    } else {
                        // Use last annotations (excluding actions)
                        const lastContext = inputHistory.context && inputHistory.context.length > 0 ? inputHistory.context[0] : '';
                        const lastScene = inputHistory.scene && inputHistory.scene.length > 0 ? inputHistory.scene[0] : '';
                        const lastTags = inputHistory.tags && inputHistory.tags.length > 0 ? inputHistory.tags.slice(0, 3).join(', ') : '';
                        const lastDescription = inputHistory.description && inputHistory.description.length > 0 ? inputHistory.description[0] : '';
                        
                        document.getElementById('context').value = lastContext;
                        document.getElementById('scene').value = lastScene;
                        document.getElementById('tags').value = lastTags;
                        document.getElementById('description').value = lastDescription;
                        // Leave action fields empty
                        document.getElementById('action_type').value = '';
                        document.getElementById('intent').value = '';
                        document.getElementById('outcome').value = '';
                    }
                }
            }
            
            // Populate recent buttons - restore tags
            updateRecentButtons('scene');
            updateRecentButtons('tags');
            
            document.getElementById('scene').focus();
            
            // Reset history indices
            Object.keys(currentHistoryIndex).forEach(key => {
                currentHistoryIndex[key] = -1;
            });
            
            // Set up form field navigation if not already done
            setupFormFieldNavigation();
            
            // Update modal title
            updateModalTitle();
        }
        // Function to update the frame snapshot in the modal
function updateModalFrameSnapshot() {
    const selectedFramesArray = Array.from(selectedFrames);
    if (selectedFramesArray.length === 0) {
        // Hide snapshot if no frames selected
        document.getElementById('modal-frame-snapshot').style.display = 'none';
        return;
    }
    
    // Show the last selected frame (most recently selected)
    const lastSelectedFrame = selectedFramesArray[selectedFramesArray.length - 1];
    const snapshotImage = document.getElementById('snapshot-image');
    const snapshotLabel = document.getElementById('snapshot-frame-label');
    const buttonEventsDisplay = document.getElementById('button-events-display');
    
    // Update the image source
    snapshotImage.src = apiUrl('frame_image', lastSelectedFrame);
    
    // Update the label
    if (selectedFramesArray.length === 1) {
        snapshotLabel.textContent = `Frame ${lastSelectedFrame}`;
    } else {
        snapshotLabel.textContent = `Frame ${lastSelectedFrame} (${selectedFramesArray.length} frames selected)`;
    }
    
    // Load and display button events
    buttonEventsDisplay.textContent = 'Loading button events...';
    fetch(apiUrl('frame_event', lastSelectedFrame))
        .then(res => res.ok ? res.json() : null)
        .then(data => {
            if (data && data.buttons) {
                let buttonHtml = '';
                data.buttons.forEach((button, index) => {
                    const buttonText = Array.isArray(button) ? button.join('+') : (button === 'None' ? 'None' : button);
                    buttonHtml += `[${index}]: ${buttonText}<br>`;
                });
                buttonEventsDisplay.innerHTML = buttonHtml || 'No button events recorded';
            } else {
                buttonEventsDisplay.textContent = 'No button data available';
            }
        })
        .catch(err => {
            console.error('Error loading button events:', err);
            buttonEventsDisplay.textContent = 'Error loading button events';
        });
    
    // Show the snapshot
    document.getElementById('modal-frame-snapshot').style.display = 'flex';
}
        function closeModal() {
            document.getElementById('annotation-modal').style.display = 'none';
            document.getElementById('annotation-form').reset();
            
            // Reset bulk mode
            isBulkMode = false;
            
            // Re-enable all fields
            document.getElementById('action_type').disabled = false;
            document.getElementById('intent').disabled = false;
            document.getElementById('outcome').disabled = false;
            document.getElementById('description').disabled = false;
            
            // Hide any custom input areas
            document.getElementById('context_custom').style.display = 'none';
            document.getElementById('action_type_custom').style.display = 'none';
            document.getElementById('intent_custom').style.display = 'none';
            
            // Clear custom input fields
            document.getElementById('context_input').value = '';
            document.getElementById('action_type_input').value = '';
            document.getElementById('intent_input').value = '';
        }
        
        // Clear copied annotation data
        function clearCopiedAnnotation() {
            copiedAnnotation = null;
            updateModalTitle();
            // Clear the form fields
            document.getElementById('context').value = '';
            document.getElementById('scene').value = '';
            document.getElementById('tags').value = '';
            document.getElementById('description').value = '';
            document.getElementById('action_type').value = '';
            document.getElementById('intent').value = '';
            document.getElementById('outcome').value = '';
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                if (selectedFrames.size > 0) {
                    openModal();
                    e.preventDefault();
                }
            }
        });
        document.getElementById('annotation-form').onsubmit = function(e) {
            e.preventDefault();
            
            // Check if frames are selected
            const framesToUpdate = Array.from(selectedFrames);
            if (framesToUpdate.length === 0) {
                alert('Please select at least one frame to annotate.');
                return;
            }
            
            const context = document.getElementById('context').value;
            const scene = document.getElementById('scene').value;
            const tags = document.getElementById('tags').value;
            const description = document.getElementById('description').value;
            const action_type = document.getElementById('action_type').value;
            const intent = document.getElementById('intent').value;
            const outcome = document.getElementById('outcome').value;
            
            // Add values to input history
            addToHistory('context', context);
            addToHistory('scene', scene);
            addToHistory('tags', tags);
            if (!isBulkMode) {
                // Only add these to history in normal mode
                addToHistory('description', description);
                if (action_type && action_type.trim()) addToHistory('action_type', action_type);
                if (intent && intent.trim()) addToHistory('intent', intent);
                if (outcome && outcome.trim()) addToHistory('outcome', outcome);
            }
            
            // Build annotation object
            let annotation;
            if (isBulkMode) {
                // In bulk mode, only include context, scene, and tags
                annotation = { 
                    context, 
                    scene, 
                    tags,
                    description: '', // Clear description in bulk mode
                    action_type: '', // Clear action fields in bulk mode
                    intent: '',
                    outcome: ''
                };
            } else {
                // Normal mode - include all fields
                annotation = { 
                    context, 
                    scene, 
                    tags, 
                    description,
                    action_type: action_type || '',
                    intent: intent || '',
                    outcome: outcome || ''
                };
            }
            
            console.log('Submitting annotation:', annotation);
            console.log('For frames:', framesToUpdate);
            console.log('Bulk mode:', isBulkMode);
            
            fetch(apiUrl('annotate'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ frames: framesToUpdate, annotation })
            }).then(res => res.json()).then(data => {
                console.log('Server response:', data);
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                // Only update the annotated frames' borders
                framesToUpdate.forEach(frame => {
                    const div = document.getElementById('frame-' + frame);
                    if (div) {
                        div.classList.add('annotated');
                        div.classList.remove('selected'); // Remove selection styling
                    }
                });
                selectedFrames.clear();
                updateBulkAnnotateButton(); // Update button state
                closeModal();
                
                // Update completion stats after saving annotations
                updateCompletionStats();
            }).catch(err => {
                console.error('Error saving annotation:', err);
                alert('Error saving annotation: ' + err.message);
            });
        };

        // Reset annotations for selected frames
        function resetAnnotations() {
            const framesToReset = Array.from(selectedFrames);
            if (framesToReset.length === 0) {
                alert('Please select at least one frame to reset annotations for.');
                return;
            }
            
            const confirmReset = confirm(`Are you sure you want to reset annotations for ${framesToReset.length} frame(s)? This will clear all annotation data for the selected frames.`);
            if (!confirmReset) {
                return;
            }
            
            // Create empty annotation object
            const emptyAnnotation = {
                context: '',
                scene: '',
                tags: '',
                description: '',
                action_type: '',
                intent: '',
                outcome: ''
            };
            
            console.log('Resetting annotations for frames:', framesToReset);
            
            fetch(apiUrl('annotate'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ frames: framesToReset, annotation: emptyAnnotation })
            }).then(res => res.json()).then(data => {
                console.log('Reset response:', data);
                if (data.error) {
                    alert('Error: ' + data.error);
                    return;
                }
                
                // Remove annotated styling from the frames
                framesToReset.forEach(frame => {
                    const div = document.getElementById('frame-' + frame);
                    if (div) {
                        div.classList.remove('annotated');
                        div.classList.remove('selected'); // Remove selection styling
                    }
                });
                
                selectedFrames.clear();
                updateBulkAnnotateButton(); // Update button state
                closeModal();
                
                // Update completion stats after resetting annotations
                updateCompletionStats();
                
                alert(`Annotations reset for ${framesToReset.length} frame(s).`);
                
            }).catch(err => {
                console.error('Error resetting annotations:', err);
                alert('Error resetting annotations: ' + err.message);
            });
        }

        // Initialize the page
        window.onload = async function() {
            currentSessionId = getCurrentSessionId();
            await loadAnnotationConfig(); // Load config before other operations
            initializeRecentButtons(); // Initialize recent buttons
            refreshSessions();
            updateBulkAnnotateButton(); // Initialize bulk button state
            if (currentSessionId) {
                loadFrames();
            }
            
            // Add optimized scroll event listener
            window.addEventListener('scroll', handleScrollEvents, { passive: true });
        };
        
        // Inject to Database function
        function injectToDatabase() {
            // TODO: Implement database injection functionality
            alert('Database injection functionality will be implemented here.');
        }

        // Toggle Annotated Frames visibility
        let annotatedFramesHidden = false;
        function toggleAnnotatedFrames() {
            const button = event.target;
            const annotatedFrames = document.querySelectorAll('.frame-item.annotated');
            
            if (annotatedFramesHidden) {
                // Show annotated frames
                annotatedFrames.forEach(frame => {
                    frame.style.display = '';
                });
                button.innerHTML = 'üëÅÔ∏è Hide Annotated Frames';
                button.title = 'Hide annotated frames';
                annotatedFramesHidden = false;
            } else {
                // Hide annotated frames
                annotatedFrames.forEach(frame => {
                    frame.style.display = 'none';
                });
                button.innerHTML = 'üëÅÔ∏è Show Annotated Frames';
                button.title = 'Show annotated frames';
                annotatedFramesHidden = true;
            }
        }
    </script>
</body>
</html>
